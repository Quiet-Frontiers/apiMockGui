import axios from 'axios';
import MockAdapter from 'axios-mock-adapter';
export class MockServer {
    constructor(config = {}) {
        Object.defineProperty(this, "mockAdapter", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
        });
        Object.defineProperty(this, "config", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "isRunning", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "handlerCount", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "hasBeenStarted", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        }); // Ìïú Î≤àÏù¥ÎùºÎèÑ ÏãúÏûëÎêú Ï†ÅÏù¥ ÏûàÎäîÏßÄ Ï∂îÏ†Å
        Object.defineProperty(this, "trackedInstances", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new Set()
        }); // Ï∂îÏ†Å Ï§ëÏù∏ axios Ïù∏Ïä§ÌÑ¥Ïä§Îì§
        this.config = {
            environment: 'browser',
            onUnhandledRequest: 'bypass',
            ...config
        };
        // axios.create Î©îÏÑúÎìúÎ•º Ïò§Î≤ÑÎùºÏù¥ÎìúÌïòÏó¨ ÏÉàÎ°ú ÏÉùÏÑ±ÎêòÎäî Ïù∏Ïä§ÌÑ¥Ïä§ÎèÑ Ï∂îÏ†Å
        this.interceptAxiosCreate();
        console.log('üé≠ MockServer Ïù∏Ïä§ÌÑ¥Ïä§Í∞Ä ÏÉùÏÑ±ÎêòÏóàÏäµÎãàÎã§.');
    }
    interceptAxiosCreate() {
        const originalCreate = axios.create;
        axios.create = (config) => {
            const instance = originalCreate.call(axios, config);
            this.trackedInstances.add(instance);
            // Ïù¥ÎØ∏ Ïã§Ìñâ Ï§ëÏù∏ mock serverÍ∞Ä ÏûàÎã§Î©¥ ÏÉà Ïù∏Ïä§ÌÑ¥Ïä§ÏóêÎèÑ Ï†ÅÏö©
            if (this.isRunning && this.mockAdapter) {
                this.applyMockToInstance(instance);
            }
            return instance;
        };
    }
    applyMockToInstance(instance) {
        if (!this.mockAdapter)
            return;
        // Í∞Å Ïù∏Ïä§ÌÑ¥Ïä§Ïóê ÎèôÏùºÌïú mock adapterÎ•º Ï†ÅÏö©
        const instanceMock = new MockAdapter(instance, {
            delayResponse: 0,
            onNoMatch: this.config.onUnhandledRequest === 'bypass' ? 'passthrough' : 'throwException'
        });
        // ÌòÑÏû¨ ÏÑ§Ï†ïÎêú Î™®Îì† Ìï∏Îì§Îü¨Î•º ÏÉà Ïù∏Ïä§ÌÑ¥Ïä§ÏóêÎèÑ Ï†ÅÏö©
        // (Ïù¥Í≤ÉÏùÄ updateHandlersÍ∞Ä Ìò∏Ï∂úÎê† Îïå ÏûêÎèôÏúºÎ°ú Ï≤òÎ¶¨Îê®)
    }
    async start() {
        if (this.isRunning) {
            console.warn('üîÑ Mock serverÍ∞Ä Ïù¥ÎØ∏ Ïã§Ìñâ Ï§ëÏûÖÎãàÎã§.');
            return;
        }
        try {
            // 1. Í∏∞Î≥∏ axios Ïù∏Ïä§ÌÑ¥Ïä§Ïóê mock adapter Ï†ÅÏö©
            this.mockAdapter = new MockAdapter(axios, {
                delayResponse: 0,
                onNoMatch: this.config.onUnhandledRequest === 'bypass' ? 'passthrough' : 'throwException'
            });
            // 2. Ïù¥ÎØ∏ ÏÉùÏÑ±Îêú Î™®Îì† axios Ïù∏Ïä§ÌÑ¥Ïä§ÏóêÎèÑ mock Ï†ÅÏö©
            this.trackedInstances.forEach(instance => {
                this.applyMockToInstance(instance);
            });
            this.isRunning = true;
            this.hasBeenStarted = true; // ÏãúÏûëÎê®ÏùÑ ÌëúÏãú
            console.log('‚úÖ Mock serverÍ∞Ä ÏÑ±Í≥µÏ†ÅÏúºÎ°ú ÏãúÏûëÎêòÏóàÏäµÎãàÎã§');
            console.log(`üì° ${this.trackedInstances.size + 1}Í∞úÏùò axios Ïù∏Ïä§ÌÑ¥Ïä§Ïóê MockÏù¥ Ï†ÅÏö©ÎêòÏóàÏäµÎãàÎã§ (Í∏∞Î≥∏ + ÏÉùÏÑ±Îêú Ïù∏Ïä§ÌÑ¥Ïä§Îì§)`);
        }
        catch (error) {
            console.error('‚ùå Mock server ÏãúÏûë Ïã§Ìå®:', error);
            throw error;
        }
    }
    async stop() {
        if (!this.isRunning) {
            console.warn('‚ö†Ô∏è  Mock serverÍ∞Ä Ïã§ÌñâÎêòÍ≥† ÏûàÏßÄ ÏïäÏäµÎãàÎã§.');
            return;
        }
        try {
            if (this.mockAdapter) {
                this.mockAdapter.restore();
                this.mockAdapter = null;
            }
            // Î™®Îì† Ï∂îÏ†ÅÎêú Ïù∏Ïä§ÌÑ¥Ïä§Ïùò mockÎèÑ Ï†ïÎ¶¨
            this.trackedInstances.forEach(instance => {
                try {
                    // axios-mock-adapterÍ∞Ä Ïù∏Ïä§ÌÑ¥Ïä§Ïóê ÏÑ§Ï†ïÎêòÏñ¥ ÏûàÎã§Î©¥ Ï†ïÎ¶¨
                    instance.__mockAdapter?.restore?.();
                }
                catch (error) {
                    // Î¨¥Ïãú - Ïù¥ÎØ∏ Ï†ïÎ¶¨ÎêòÏóàÍ±∞ÎÇò ÏÑ§Ï†ïÎêòÏßÄ ÏïäÏùå
                }
            });
            this.isRunning = false;
            this.handlerCount = 0;
            console.log('üõë Mock serverÍ∞Ä Ï§ëÏßÄÎêòÏóàÏäµÎãàÎã§.');
        }
        catch (error) {
            console.error('‚ùå Mock server Ï§ëÏßÄ Ïã§Ìå®:', error);
            throw error;
        }
    }
    updateHandlers(apis) {
        if (!this.mockAdapter) {
            if (this.isRunning) {
                console.error('‚ö†Ô∏è  Mock adapterÍ∞Ä Ï¥àÍ∏∞ÌôîÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§. Mock serverÎ•º Ïû¨ÏãúÏûëÌï¥ Ï£ºÏÑ∏Ïöî.');
            }
            else if (this.hasBeenStarted) {
                // Ìïú Î≤à ÏãúÏûëÎêú Ï†ÅÏù¥ ÏûàÏóàÎäîÎç∞ ÏßÄÍ∏à Ï§ëÏßÄÎêú Í≤ΩÏö∞ÏóêÎßå Í≤ΩÍ≥†
                console.warn('üí° Mock serverÍ∞Ä Ïã§ÌñâÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§. Î®ºÏ†Ä ÏÑúÎ≤ÑÎ•º ÏãúÏûëÌï¥ Ï£ºÏÑ∏Ïöî.');
            }
            // Ï¥àÍ∏∞ Î°úÎî© ÏãúÏóêÎäî ÏïÑÎ¨¥ Î©îÏãúÏßÄÎèÑ ÌëúÏãúÌïòÏßÄ ÏïäÏùå
            return;
        }
        // Í∏∞Ï°¥ Ìï∏Îì§Îü¨ Ï¥àÍ∏∞Ìôî
        this.mockAdapter.reset();
        // ÏÉàÎ°úÏö¥ Ìï∏Îì§Îü¨ Îì±Î°ù
        this.createHandlers(apis);
        // Î™®Îì† Ï∂îÏ†ÅÎêú Ïù∏Ïä§ÌÑ¥Ïä§ÏóêÎèÑ ÎèôÏùºÌïú Ìï∏Îì§Îü¨ Ï†ÅÏö©
        this.trackedInstances.forEach(instance => {
            try {
                const instanceMock = new MockAdapter(instance, {
                    delayResponse: 0,
                    onNoMatch: this.config.onUnhandledRequest === 'bypass' ? 'passthrough' : 'throwException'
                });
                this.createHandlersForAdapter(instanceMock, apis);
            }
            catch (error) {
                console.warn('ÏùºÎ∂Ä axios Ïù∏Ïä§ÌÑ¥Ïä§Ïóê mock Ï†ÅÏö© Ïã§Ìå®:', error);
            }
        });
        this.handlerCount = this.getEnabledApiCount(apis);
        if (this.handlerCount > 0) {
            console.log(`üì° ${this.handlerCount}Í∞úÏùò Mock API Ìï∏Îì§Îü¨Í∞Ä ÏóÖÎç∞Ïù¥Ìä∏ÎêòÏóàÏäµÎãàÎã§.`);
            console.log(`üîó ${this.trackedInstances.size + 1}Í∞úÏùò axios Ïù∏Ïä§ÌÑ¥Ïä§Ïóê Ï†ÅÏö©Îê®`);
        }
    }
    createHandlers(apis) {
        if (!this.mockAdapter)
            return;
        this.createHandlersForAdapter(this.mockAdapter, apis);
    }
    createHandlersForAdapter(adapter, apis) {
        apis.forEach(api => {
            if (!api.isEnabled)
                return;
            const activeCase = api.cases.find(c => c.id === api.activeCase) || api.cases.find(c => c.isActive);
            if (!activeCase)
                return;
            const fullPath = this.buildFullPath(api.path);
            const method = api.method.toLowerCase();
            // axios-mock-adapter Ìï∏Îì§Îü¨ Îì±Î°ù
            try {
                switch (method) {
                    case 'get':
                        adapter.onGet(fullPath).reply(async () => {
                            if (activeCase.delay && activeCase.delay > 0) {
                                await new Promise(resolve => setTimeout(resolve, activeCase.delay));
                            }
                            return [activeCase.status, activeCase.body, activeCase.headers || {}];
                        });
                        break;
                    case 'post':
                        adapter.onPost(fullPath).reply(async () => {
                            if (activeCase.delay && activeCase.delay > 0) {
                                await new Promise(resolve => setTimeout(resolve, activeCase.delay));
                            }
                            return [activeCase.status, activeCase.body, activeCase.headers || {}];
                        });
                        break;
                    case 'put':
                        adapter.onPut(fullPath).reply(async () => {
                            if (activeCase.delay && activeCase.delay > 0) {
                                await new Promise(resolve => setTimeout(resolve, activeCase.delay));
                            }
                            return [activeCase.status, activeCase.body, activeCase.headers || {}];
                        });
                        break;
                    case 'delete':
                        adapter.onDelete(fullPath).reply(async () => {
                            if (activeCase.delay && activeCase.delay > 0) {
                                await new Promise(resolve => setTimeout(resolve, activeCase.delay));
                            }
                            return [activeCase.status, activeCase.body, activeCase.headers || {}];
                        });
                        break;
                    case 'patch':
                        adapter.onPatch(fullPath).reply(async () => {
                            if (activeCase.delay && activeCase.delay > 0) {
                                await new Promise(resolve => setTimeout(resolve, activeCase.delay));
                            }
                            return [activeCase.status, activeCase.body, activeCase.headers || {}];
                        });
                        break;
                    default:
                        console.warn(`Unsupported HTTP method: ${method}`);
                }
            }
            catch (error) {
                console.error(`Failed to register handler for ${method.toUpperCase()} ${fullPath}:`, error);
            }
        });
    }
    buildFullPath(path) {
        const baseUrl = this.config.baseUrl || '';
        let fullPath = baseUrl + path;
        // URL ÌååÎùºÎØ∏ÌÑ∞Î•º Ï†ïÍ∑úÌëúÌòÑÏãùÏúºÎ°ú Î≥ÄÌôò (/api/users/:id -> /api/users/\d+)
        if (fullPath.includes(':')) {
            const regexPath = fullPath.replace(/:[\w]+/g, '\\d+');
            return new RegExp(regexPath);
        }
        return fullPath;
    }
    getEnabledApiCount(apis) {
        return apis.filter(api => api.isEnabled && (api.cases.find(c => c.id === api.activeCase) || api.cases.find(c => c.isActive))).length;
    }
    getHandlerCount() {
        return this.handlerCount;
    }
    getConfig() {
        return { ...this.config };
    }
}
// Í∏ÄÎ°úÎ≤å Ïù∏Ïä§ÌÑ¥Ïä§Î•º ÏúÑÌïú Ìå©ÌÜ†Î¶¨ Ìï®Ïàò
let globalMockServer = null;
export function createMockServer(config) {
    return new MockServer(config);
}
export function getGlobalMockServer(config) {
    if (!globalMockServer) {
        globalMockServer = new MockServer(config);
    }
    return globalMockServer;
}
